<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Drag & Drop with Image Options</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
body {
  margin: 0;
  background: #0f172a;
  font-family: system-ui, sans-serif;
}

.canvas-container {
  position: relative;
  width: 100vw;
  height: 100vh;
  background: black;
  overflow: hidden;
}

.video-canvas,
.landmarks-canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
}

.status {
  position: absolute;
  bottom: 20px;
  left: 20px;
  color: white;
  font-size: 14px;
  z-index: 20;
}

.question-box {
  position: fixed;
  width: 450px;
  height: auto;
  z-index: 50;
  background: rgba(15, 23, 42, 0.28);
  color: #e5e7eb;
  padding: 18px;
  border-radius: 16px;
  font-size: 16px;
  line-height: 1.5;
  box-shadow: 0 14px 40px rgba(0,0,0,0.4);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
}

.question-top-right { top: 20px; right: 20px; }
.answer-bottom-left { bottom: 20px; left: 20px; }

.question-title {
  font-weight: 800;
  margin-bottom: 12px;
  font-size: 18px;
}

.question-divider {
  height: 1px;
  background: rgba(255,255,255,0.18);
  margin: 12px 0;
}

.answer-box {
  flex: 1;
  border-radius: 12px;
  background: rgba(0,0,0,0.25);
  padding: 14px;
  overflow: hidden;
}

/* ‚úÖ TOP CENTER PROGRESS */
#progressTop {
  position: fixed;
  top: 18px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 999999;

  padding: 10px 18px;
  border-radius: 14px;

  background: rgba(0, 0, 0, 0.55);
  border: 1px solid rgba(255, 255, 255, 0.18);
  backdrop-filter: blur(12px);

  color: #60a5fa;
  font-size: 16px;
  font-weight: 900;
  letter-spacing: 1px;
}

#progressTop.pop {
  animation: progressPop 0.35s ease;
}

@keyframes progressPop {
  0%   { transform: translateX(-50%) scale(1); }
  50%  { transform: translateX(-50%) scale(1.25); }
  100% { transform: translateX(-50%) scale(1); }
}

/* ‚úÖ HUD TOP LEFT (Score + Lives) */
#hudTopLeft {
  position: fixed;
  top: 18px;
  left: 18px;
  z-index: 999999;

  padding: 10px 14px;
  border-radius: 14px;

  background: rgba(0, 0, 0, 0.55);
  border: 1px solid rgba(255, 255, 255, 0.18);
  backdrop-filter: blur(12px);

  color: #e5e7eb;
  font-size: 14px;
  font-weight: 800;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.hud-row {
  display: flex;
  gap: 10px;
  align-items: center;
}

.hud-label {
  opacity: 0.8;
  font-weight: 700;
}

.hud-value {
  font-weight: 900;
  color: #38bdf8;
}

#livesValue {
  color: #fb7185;
}

/* IMAGE OPTIONS STYLES */
.image-options-container {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-top: 10px;
}

.image-option {
  position: relative;
  cursor: pointer;
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.25s ease;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  width: 100%;
  height: 100px;
}

.image-option img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  pointer-events: none;
}

.image-option:hover {
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-2px);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
}

.image-option.targeted {
  border-color: rgba(59, 130, 246, 0.95);
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(29, 78, 216, 0.2) 100%);
  transform: scale(1.03);
  box-shadow: 0 0 25px rgba(59, 130, 246, 0.5);
}

.image-option.dragging {
  opacity: 0.25;
  transform: scale(0.95);
}

.image-option-label {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 700;
  font-size: 18px;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.9);
  text-align: center;
  padding: 0 15px;
  z-index: 2;
  line-height: 1.3;
  flex-direction: column;
}

.image-option-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1;
}

.option-letter {
  font-weight: 900;
  font-size: 24px;
  color: #60a5fa;
  margin-bottom: 5px;
  background: rgba(0, 0, 0, 0.7);
  padding: 4px 12px;
  border-radius: 8px;
  display: inline-block;
}

.option-text {
  background: rgba(0, 0, 0, 0.6);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 16px;
  max-width: 90%;
  text-align: center;
}

/* DRAG GHOST */
.drag-ghost {
  position: fixed;
  z-index: 99999;
  width: 400px;
  height: 90px;
  border-radius: 12px;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  border: 2px solid rgba(59, 130, 246, 0.8);
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.7);
  transform: translate(-50%, -50%);
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.drag-ghost .ghost-text {
  color: white;
  font-weight: 700;
  font-size: 18px;
  text-align: center;
  padding: 15px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

.ghost-letter {
  font-weight: 900;
  font-size: 22px;
  color: #60a5fa;
  background: rgba(0, 0, 0, 0.7);
  padding: 5px 12px;
  border-radius: 8px;
}

/* Hide elements until drop */
.hidden {
  display: none !important;
}

/* BIG INVISIBLE DROP ZONE */
.drop-zone {
  position: relative;
  margin-top: 14px;
  width: 100%;
  min-height:640px;
 
  background: transparent;
  border: none;
  box-shadow: none;

  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.drop-zone::before {
  content: "";
  position: absolute;
  inset: -50px;
}

.drop-value {
  margin-top: 10px;
  font-size: 20px;
  font-weight: 700;
  color: #38bdf8;
  text-align: center;
  padding: 15px;
  background: rgba(8, 8, 8, 0.89);
  border-radius: 10px;
  width: 100%;
  min-height: 60px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

.answer-letter {
  font-weight: 900;
  font-size: 22px;
  color: #60a5fa;
  background: rgba(0, 0, 0, 0.5);
  padding: 6px 15px;
  border-radius: 8px;
  margin-bottom: 5px;
}

.result-text {
  margin-top: 12px;
  font-size: 14px;
  font-weight: 500;
  text-align: center;
  min-height: 24px;
  padding: 8px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.2);
}

/* CURSOR */
.cursor {
  position: fixed;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: rgba(34, 197, 94, 0.95);
  border: 4px solid white;
  z-index: 99998;
  transform: translate(-50%, -50%);
  pointer-events: none;
  display: none;
  box-shadow: 0 0 22px rgba(34, 197, 94, 0.7);
}
.cursor.pinching {
  width: 36px;
  height: 36px;
  background: rgba(239, 68, 68, 0.95);
}

.debug-badge {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 99999;
  background: rgba(0,0,0,0.55);
  border: 1px solid rgba(255,255,255,0.2);
  color: rgba(229,231,235,0.95);
  padding: 10px 12px;
  border-radius: 12px;
  font-size: 13px;
  backdrop-filter: blur(10px);
}

/* Congrats overlay */
.congrats-overlay {
  position: fixed;
  inset: 0;
  z-index: 999999;
  pointer-events: none;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.25);
  backdrop-filter: blur(3px);
}

.congrats-overlay.show {
  display: flex;
  animation: fadeInOut 1.2s ease forwards;
}

.congrats-box {
  padding: 22px 34px;
  border-radius: 18px;
  font-size: 26px;
  font-weight: 900;
  color: white;
  background: linear-gradient(135deg, rgba(34,197,94,0.85), rgba(59,130,246,0.85));
  box-shadow: 0 0 40px rgba(59, 130, 246, 0.55);
  transform: scale(0.9);
  animation: popIn 0.45s ease forwards;
  text-align: center;
}

@keyframes popIn {
  0% { transform: scale(0.7); opacity: 0; }
  100% { transform: scale(1.05); opacity: 1; }
}

@keyframes fadeInOut {
  0% { opacity: 0; }
  15% { opacity: 1; }
  85% { opacity: 1; }
  100% { opacity: 0; }
}

/* confetti */
.confetti {
  position: fixed;
  width: 10px;
  height: 14px;
  border-radius: 3px;
  opacity: 0.95;
  z-index: 999998;
  pointer-events: none;
  animation: confettiFall 1.2s ease forwards;
}

@keyframes confettiFall {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(500px) rotate(720deg); opacity: 0; }
}

/* ‚úÖ FINAL RESULT SCREEN */
#finalScreen {
  position: fixed;
  inset: 0;
  z-index: 999999;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(12px);
  display: none;
  align-items: center;
  justify-content: center;
}

#finalScreen.show {
  display: flex;
}

.final-card {
  width: 520px;
  max-width: 92vw;
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 20px;
  padding: 24px;
  box-shadow: 0 24px 70px rgba(0,0,0,0.55);
  text-align: center;
  color: white;
}

.final-title {
  font-size: 26px;
  font-weight: 900;
  margin-bottom: 12px;
  color: #38bdf8;
}

/* ‚úÖ Final selfie */
.final-photo {
  width: 150px;
  height: 150px;
  border-radius: 18px;
  object-fit: cover;
  border: 2px solid rgba(255,255,255,0.18);
  box-shadow: 0 14px 40px rgba(0,0,0,0.45);
  margin: 10px auto 18px;
  display: block;
}

.final-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin: 18px 0;
}

.stat-box {
  padding: 14px;
  border-radius: 14px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
}

.stat-label {
  opacity: 0.85;
  font-weight: 700;
  font-size: 14px;
}

.stat-value {
  margin-top: 6px;
  font-size: 22px;
  font-weight: 900;
  color: #4ade80;
}

/* ‚úÖ NEW: Restart Symbol */
.restart-symbol {
  margin-top: 20px;
  width: 120px;
  height: 120px;
  margin-left: auto;
  margin-right: auto;
  border-radius: 50%;
  background: linear-gradient(135deg, #3b82f6, #22c55e);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 60px;
  cursor: pointer;
  transition: all 0.3s ease;
  border: 3px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
  position: relative;
}

.restart-symbol:hover {
  transform: scale(1.05);
  box-shadow: 0 15px 40px rgba(59, 130, 246, 0.5);
}

.restart-symbol.targeted {
  transform: scale(1.15);
  border-color: rgba(255, 255, 255, 0.8);
  box-shadow: 0 0 40px rgba(59, 130, 246, 0.8);
  animation: pulse 0.8s ease infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1.15); }
  50% { transform: scale(1.2); }
}

.restart-hint {
  margin-top: 12px;
  font-size: 14px;
  font-weight: 600;
  color: #94a3b8;
  text-align: center;
}
</style>
</head>

<body>

<div id="progressTop">1/7</div>

<div id="hudTopLeft">
  <div class="hud-row"><span class="hud-label">Score:</span> <span id="scoreValue" class="hud-value">0</span></div>
  <div class="hud-row"><span class="hud-label">Lives:</span> <span id="livesValue">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
</div>

<div class="question-box question-top-right" id="questionBox">
  <div class="question-title">‚ùì Question</div>
  <div class="question-divider"></div>

  <div class="answer-box">
    <div id="questionText" style="font-size:18px;font-weight:900;color:white;">
      Question will appear here‚Ä¶
    </div>

    <div class="drop-zone" id="dropZone">
      <div class="drop-value hidden" id="droppedAnswer">‚Äî</div>
      <div class="result-text hidden" id="resultText">‚Äî</div>
    </div>
  </div>
</div>

<div class="question-box answer-bottom-left" id="optionsPanel">
  <div class="question-title">üß© Options</div>
  <div class="question-divider"></div>
  <div class="answer-box">
    <div class="image-options-container" id="imageOptionsBox"></div>
  </div>
</div>

<div class="canvas-container" id="canvasContainer">
  <canvas class="video-canvas" id="videoCanvas"></canvas>
  <canvas class="landmarks-canvas" id="landmarksCanvas"></canvas>
  <div class="status" id="statusText">Tracking</div>
</div>

<video id="video" autoplay playsinline style="display:none"></video>
<div class="cursor" id="cursor"></div>
<div class="debug-badge" id="debugBadge">Ready</div>

<div class="congrats-overlay" id="congratsOverlay">
  <div class="congrats-box">üéâ Congratulations! ‚úÖ</div>
</div>

<div id="finalScreen">
  <div class="final-card">
    <div class="final-title">üèÅ Quiz Finished!</div>

    <!-- ‚úÖ Selfie preview -->
    <img id="finalSelfie" class="final-photo" src="" alt="Selfie" />

    <div id="finalMsg" style="font-weight:800;opacity:0.9;margin-bottom:14px;">
      Great Job!
    </div>

    <div class="final-stats">
      <div class="stat-box">
        <div class="stat-label">‚úÖ Correct</div>
        <div class="stat-value" id="finalCorrect">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">‚ùå Wrong</div>
        <div class="stat-value" id="finalWrong">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">‚≠ê Score</div>
        <div class="stat-value" id="finalScore">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">‚ù§Ô∏è Lives Left</div>
        <div class="stat-value" id="finalLives">0</div>
      </div>
    </div>

    <!-- ‚úÖ NEW: Restart Symbol instead of button -->
    <div class="restart-symbol" id="restartSymbol">üîÑ</div>
    <div class="restart-hint">üëÜ Pinch to restart</div>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const CONFIDENCE_THRESHOLD = 0.6;
const HIDE_DELAY = 15000;
const PINCH_THRESHOLD = 0.075;
const SMOOTHING = 0.35;

const SCORE_CORRECT = 10;
const SCORE_WRONG = 2;
const MAX_LIVES = 3;

/* ================= QUESTION DATA ================= */
const questions = [
  {
    q: "What is the purpose of this application?",
    options: [
      "Entertainment and gaming",
      "Production scheduling and process management",
      "Customer support ticket handling",
      "Social media content management"
    ],
    correct: 1
  },
  {
    q: "What problem does this application solve?",
    options: [
      "Communication gaps between customers and support teams",
      "Data storage and backup issues",
      "Inefficiency in task and production management",
      "Online payment processing delays"
    ],
    correct: 2
  },
  {
    q: "Who is the target user of this application?",
    options: [
      "School and college students",
      "Manufacturing and production units",
      "Retail customers",
      "Social media influencers"
    ],
    correct: 1
  },
  {
    q: "On which platforms is the application available?",
    options: [
      "Mobile only",
      "Web, mobile, and desktop",
      "Web only",
      "Desktop only"
    ],
    correct: 1
  },
  {
    q: "What type of data does the application collect and store?",
    options: [
      "Production orders, resources, timelines, and progress updates",
      "Customer profiles and marketing metrics",
      "Social media posts and engagement data",
      "Audio and video streaming data"
    ],
    correct: 0
  },
  {
    q: "What kind of reports or analytics does this application provide?",
    options: [
      "Production schedules, resource utilization, progress tracking, and bottleneck identification",
      "Customer demographics and buying behavior",
      "Website traffic and SEO performance",
      "Employee attendance and payroll reports"
    ],
    correct: 0
  },
  {
    q: "Which industries can use this application?",
    options: [
      "Manufacturing, automotive, aerospace, and pharmaceuticals",
      "Retail, hospitality, and tourism",
      "Education and e-learning platforms",
      "Media and entertainment industries"
    ],
    correct: 0
  }
];

let currentQuestionIndex = 0;

/* ================= GAME STATE ================= */
let score = 0;
let lives = MAX_LIVES;
let correctCount = 0;
let wrongCount = 0;

const state = {
  cursorX: 0,
  cursorY: 0,
  smoothX: null,
  smoothY: null,
  cursorVisible: false,
  isPinching: false,
  wasPinching: false,
  dragging: false,
  draggedOptionIndex: null,
  draggedOptionText: null,
  ghostEl: null,
  targetedOptionIndex: null,
  lastHandSeen: Date.now(),
  restartTargeted: false,
  gameEnded: false
};

/* ================= DOM ================= */
const questionText = document.getElementById("questionText");
const optionsPanel = document.getElementById("optionsPanel");
const imageOptionsBox = document.getElementById("imageOptionsBox");
const droppedAnswer = document.getElementById("droppedAnswer");
const resultText = document.getElementById("resultText");
const cursorEl = document.getElementById("cursor");
const debugBadge = document.getElementById("debugBadge");
const dropZone = document.getElementById("dropZone");
const canvasContainer = document.getElementById("canvasContainer");
const statusText = document.getElementById("statusText");

const progressTop = document.getElementById("progressTop");
const scoreValue = document.getElementById("scoreValue");
const livesValue = document.getElementById("livesValue");

const finalScreen = document.getElementById("finalScreen");
const finalCorrect = document.getElementById("finalCorrect");
const finalWrong = document.getElementById("finalWrong");
const finalScore = document.getElementById("finalScore");
const finalLives = document.getElementById("finalLives");
const finalMsg = document.getElementById("finalMsg");
const restartSymbol = document.getElementById("restartSymbol");

/* ‚úÖ Video + selfie */
const videoEl = document.getElementById("video");
const finalSelfie = document.getElementById("finalSelfie");

/* ‚úÖ Sound Effects */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playBeep(freq=440, duration=0.12){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.value = freq;
  g.gain.value = 0.07;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  setTimeout(()=>{ o.stop(); }, duration * 1000);
}
function soundCorrect(){ playBeep(880, 0.14); playBeep(1100, 0.12); }
function soundWrong(){ playBeep(220, 0.18); }
function soundFinish(){ playBeep(660, 0.14); playBeep(880, 0.14); playBeep(990, 0.14); }

/* ================= CONTEXTUAL IMAGES ================= */
const questionImageData = [
  { images: ["images/AA.jpeg", "images/AB.jpeg", "images/AC.jpeg","images/AD.jpeg"] },
  { images: ["images/BA.jpeg", "images/BB.jpeg", "images/BC.jpeg","images/BD.jpeg"] },
  { images: ["images/CA.jpeg", "images/CB.jpeg", "images/CC.jpeg","images/CD.jpeg"] },
  { images: ["images/DA.jpeg", "images/DB.jpeg", "images/DC.jpeg","images/DD.jpeg"] },
  { images: ["images/EA.jpeg", "images/EB.jpeg","images/EC.jpeg","images/ED.jpeg"] },
  { images: ["images/FA.jpeg", "images/FB.jpeg","images/FC.jpeg","images/FD.jpeg"] },
  { images: ["images/GA.jpeg", "images/GB.jpeg","images/GC.jpeg","images/GD.jpeg"] }
];

/* ================= HELPERS ================= */
function rect(el){ return el.getBoundingClientRect(); }
function inRect(x,y,r){ return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom; }

function updateCursorUI(){
  if(!state.cursorVisible){
    cursorEl.style.display="none";
    return;
  }
  cursorEl.style.display="block";
  cursorEl.style.left = `${state.cursorX}px`;
  cursorEl.style.top  = `${state.cursorY}px`;
  cursorEl.className = "cursor" + (state.isPinching ? " pinching" : "");
}

function speakText(text) {
  if (!("speechSynthesis" in window)) return;
  window.speechSynthesis.cancel();
  const utter = new SpeechSynthesisUtterance(text);
  utter.rate = 1;
  utter.pitch = 1;
  utter.volume = 1;
  window.speechSynthesis.speak(utter);
}

function updateProgressUI(){
  progressTop.textContent = `${currentQuestionIndex + 1}/${questions.length}`;
  progressTop.classList.remove("pop");
  void progressTop.offsetWidth;
  progressTop.classList.add("pop");
}

function updateHUD(){
  scoreValue.textContent = score;
  livesValue.textContent = "‚ù§Ô∏è".repeat(lives);
}

/* ‚úÖ Capture selfie */
function captureSelfie() {
  try {
    const snapCanvas = document.createElement("canvas");
    const ctx = snapCanvas.getContext("2d");

    const w = videoEl.videoWidth || 640;
    const h = videoEl.videoHeight || 480;

    snapCanvas.width = w;
    snapCanvas.height = h;

    // ‚úÖ mirror like your video view
    ctx.translate(w, 0);
    ctx.scale(-1, 1);

    ctx.drawImage(videoEl, 0, 0, w, h);

    finalSelfie.style.display = "block";
    finalSelfie.src = snapCanvas.toDataURL("image/jpeg", 0.92);
  } catch (e) {
    console.log("Selfie capture failed:", e);
    finalSelfie.style.display = "none";
  }
}

/* ‚úÖ Final Screen */
function endGame(message){
  soundFinish();
  speakText("Quiz finished!");

  state.gameEnded = true;

  finalCorrect.textContent = correctCount;
  finalWrong.textContent = wrongCount;
  finalScore.textContent = score;
  finalLives.textContent = lives;
  finalMsg.textContent = "üì∏ Make your winning moment... Capturing in 3s!";

  finalScreen.classList.add("show");

  // ‚úÖ Capture after 3 seconds
  setTimeout(() => {
    captureSelfie();
    finalMsg.textContent = message;
  }, 3000);
}

/* Congrats effect */
function showCongratsEffect() {
  const overlay = document.getElementById("congratsOverlay");
  overlay.classList.remove("show");
  void overlay.offsetWidth;
  overlay.classList.add("show");

  const pieces = 40;
  for (let i = 0; i < pieces; i++) {
    const c = document.createElement("div");
    c.className = "confetti";

    const x = window.innerWidth / 2 + (Math.random() * 400 - 200);
    const y = window.innerHeight / 2 - 150 + (Math.random() * 120 - 60);

    c.style.left = `${x}px`;
    c.style.top = `${y}px`;

    const w = 6 + Math.random() * 10;
    const h = 8 + Math.random() * 14;
    c.style.width = `${w}px`;
    c.style.height = `${h}px`;

    const colors = ["#22c55e", "#3b82f6", "#f59e0b", "#ec4899", "#a855f7", "#ef4444"];
    c.style.background = colors[Math.floor(Math.random() * colors.length)];

    c.style.animationDuration = `${0.9 + Math.random() * 0.7}s`;
    document.body.appendChild(c);
    setTimeout(() => c.remove(), 1400);
  }

  setTimeout(() => overlay.classList.remove("show"), 1200);
}

/* ================= CREATE IMAGE OPTION ================= */
function createImageOption(text, index, optionLetter, questionIndex) {
  const optionDiv = document.createElement("div");
  optionDiv.className = "image-option";
  optionDiv.dataset.index = index;

  const img = document.createElement("img");
  const imageData = questionImageData[questionIndex];
  img.src = imageData.images[index] || "https://images.unsplash.com/photo-1550684376-efcbd6e3f031?w=450&h=100&fit=crop&crop=center";
  img.alt = text;

  const overlay = document.createElement("div");
  overlay.className = "image-option-overlay";

  const label = document.createElement("div");
  label.className = "image-option-label";

  const letterSpan = document.createElement("div");
  letterSpan.className = "option-letter";
  letterSpan.textContent = optionLetter;

  const textSpan = document.createElement("div");
  textSpan.className = "option-text";
  textSpan.textContent = text;

  label.appendChild(letterSpan);
  label.appendChild(textSpan);

  optionDiv.appendChild(img);
  optionDiv.appendChild(overlay);
  optionDiv.appendChild(label);

  return optionDiv;
}

/* ================= LOAD QUESTION ================= */
function loadQuestion(){
  if(currentQuestionIndex >= questions.length){
    endGame("üéâ Great job! You completed all questions!");
    return;
  }

  state.gameEnded = false;
  finalScreen.classList.remove("show");

  const q = questions[currentQuestionIndex];
  questionText.textContent = q.q;
  speakText(q.q);

  updateProgressUI();

  droppedAnswer.textContent = "‚Äî";
  resultText.textContent = "‚Äî";
  droppedAnswer.classList.add("hidden");
  resultText.classList.add("hidden");

  imageOptionsBox.innerHTML = "";
  q.options.forEach((optionText, index) => {
    const optionLetter = String.fromCharCode(65 + index);
    const optionDiv = createImageOption(optionText, index, optionLetter, currentQuestionIndex);
    imageOptionsBox.appendChild(optionDiv);
  });
}

loadQuestion();

/* ================= TARGET OPTION ================= */
function updateTargetedOption(){
  const imageOptions = [...imageOptionsBox.querySelectorAll(".image-option")];
  imageOptions.forEach(b => b.classList.remove("targeted"));
  state.targetedOptionIndex = null;

  if(!inRect(state.cursorX, state.cursorY, rect(optionsPanel))) return;

  let bestIdx = null;
  let best = Infinity;

  imageOptions.forEach((option,i)=>{
    const r = option.getBoundingClientRect();
    const cx = (r.left+r.right)/2;
    const cy = (r.top+r.bottom)/2;
    const scoreDist = Math.abs(state.cursorX-cx)*0.6 + Math.abs(state.cursorY-cy)*1.3;
    if(scoreDist < best){
      best = scoreDist;
      bestIdx = i;
    }
  });

  if(bestIdx !== null){
    imageOptions[bestIdx].classList.add("targeted");
    state.targetedOptionIndex = bestIdx;
  }
}

/* ‚úÖ NEW: Check if cursor is over restart symbol */
function updateRestartTargeted(){
  if(!state.gameEnded) {
    state.restartTargeted = false;
    restartSymbol.classList.remove("targeted");
    return;
  }

  const r = rect(restartSymbol);
  const over = inRect(state.cursorX, state.cursorY, r);
  
  state.restartTargeted = over;
  
  if(over){
    restartSymbol.classList.add("targeted");
  } else {
    restartSymbol.classList.remove("targeted");
  }
}

/* ================= DRAG ================= */
function startDrag(idx){
  if(state.dragging) return;

  const imageOptions = [...imageOptionsBox.querySelectorAll(".image-option")];
  const option = imageOptions[idx];
  if(option) option.classList.add("dragging");

  state.dragging = true;
  state.draggedOptionIndex = idx;

  const q = questions[currentQuestionIndex];
  state.draggedOptionText = q.options[idx];
  const optionLetter = String.fromCharCode(65 + idx);

  const ghost = document.createElement("div");
  ghost.className = "drag-ghost";

  const ghostText = document.createElement("div");
  ghostText.className = "ghost-text";

  const ghostLetter = document.createElement("div");
  ghostLetter.className = "ghost-letter";
  ghostLetter.textContent = optionLetter;

  const ghostTextSpan = document.createElement("div");
  ghostTextSpan.textContent = state.draggedOptionText;
  ghostTextSpan.style.fontSize = "16px";

  ghostText.appendChild(ghostLetter);
  ghostText.appendChild(ghostTextSpan);
  ghost.appendChild(ghostText);
  document.body.appendChild(ghost);
  state.ghostEl = ghost;

  moveGhost();
}

function moveGhost(){
  if(!state.dragging || !state.ghostEl) return;
  state.ghostEl.style.left = `${state.cursorX}px`;
  state.ghostEl.style.top  = `${state.cursorY}px`;
}

function cleanupDrag(){
  const imageOptions = [...imageOptionsBox.querySelectorAll(".image-option")];
  if(state.draggedOptionIndex !== null){
    const option = imageOptions[state.draggedOptionIndex];
    if(option) option.classList.remove("dragging");
  }

  if(state.ghostEl){
    state.ghostEl.remove();
    state.ghostEl = null;
  }

  state.dragging = false;
  state.draggedOptionIndex = null;
  state.draggedOptionText = null;
}

/* ================= DROP ================= */
function handleDrop(){
  if(!state.dragging) return;

  const ok = inRect(state.cursorX, state.cursorY, rect(dropZone));

  if(!ok){
    resultText.classList.remove("hidden");
    resultText.textContent = "‚ùå Drop inside the answer area!";
    resultText.style.color = "#f87171";
    cleanupDrag();
    return;
  }

  droppedAnswer.classList.remove("hidden");
  resultText.classList.remove("hidden");

  const optionLetter = String.fromCharCode(65 + state.draggedOptionIndex);
  droppedAnswer.innerHTML = `<div class="answer-letter">${optionLetter}</div><div>${state.draggedOptionText}</div>`;

  const q = questions[currentQuestionIndex];
  const correct = state.draggedOptionIndex === q.correct;

  if(correct){
    correctCount++;
    score += SCORE_CORRECT;
    soundCorrect();

    resultText.textContent = "‚úÖ Correct! +10";
    resultText.style.color = "#4ade80";
    speakText("Correct! Well done.");
    showCongratsEffect();

    updateHUD();
    cleanupDrag();

    setTimeout(() => {
      currentQuestionIndex++;
      loadQuestion();
    }, 1200);

  } else {
    wrongCount++;
    score = Math.max(0, score - SCORE_WRONG);
    lives--;
    soundWrong();

    resultText.textContent = `‚ùå Wrong! -${SCORE_WRONG}`;
    resultText.style.color = "#f87171";
    speakText("Wrong answer. Try again.");

    updateHUD();
    cleanupDrag();

    if(lives <= 0){
      endGame("üíÄ No lives left. Game Over!");
      return;
    }

    setTimeout(() => {
      currentQuestionIndex++;
      loadQuestion();
    }, 1200);
  }
}

/* ‚úÖ NEW: Handle restart */
function handleRestart(){
  if(!state.restartTargeted) return;
  
  playBeep(660, 0.12);
  speakText("Restarting quiz!");
  
  finalScreen.classList.remove("show");
  score = 0;
  lives = MAX_LIVES;
  correctCount = 0;
  wrongCount = 0;
  currentQuestionIndex = 0;
  state.gameEnded = false;
  updateHUD();
  loadQuestion();
}

/* ================= VISIBILITY ================= */
function updateVisibility(handDetected, confidence = 1) {
  const now = Date.now();

  if (handDetected && confidence >= CONFIDENCE_THRESHOLD) {
    state.lastHandSeen = now;
    statusText.textContent = "Tracking";
    return;
  }

  const timeMissing = now - state.lastHandSeen;

  if (timeMissing > HIDE_DELAY) {
    statusText.textContent = "Idle";
    state.cursorVisible = false;
    updateCursorUI();
    if (state.dragging) cleanupDrag();
  } else {
    statusText.textContent = `Waiting... ${Math.round((HIDE_DELAY - timeMissing) / 1000)}s`;
  }
}

/* ================= PINCH ================= */
function pinchDistance(hand){
  const thumb = hand[4];
  const index = hand[8];
  const dx = thumb.x - index.x;
  const dy = thumb.y - index.y;
  return Math.sqrt(dx*dx + dy*dy);
}

/* ================= CANVAS ================= */
const videoCanvas = document.getElementById("videoCanvas");
const landmarksCanvas = document.getElementById("landmarksCanvas");
const videoCtx = videoCanvas.getContext("2d");
const lmCtx = landmarksCanvas.getContext("2d");

function resizeCanvas(){
  videoCanvas.width = innerWidth;
  videoCanvas.height = innerHeight;
  landmarksCanvas.width = innerWidth;
  landmarksCanvas.height = innerHeight;
}
resizeCanvas();
addEventListener("resize", resizeCanvas);

function onResults(results){
  const handDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

  updateVisibility(handDetected, 1);

  videoCtx.clearRect(0,0,videoCanvas.width,videoCanvas.height);
  lmCtx.clearRect(0,0,landmarksCanvas.width,landmarksCanvas.height);

  videoCtx.save();
  videoCtx.translate(videoCanvas.width,0);
  videoCtx.scale(-1,1);
  videoCtx.drawImage(results.image,0,0,videoCanvas.width,videoCanvas.height);
  videoCtx.restore();

  if(!handDetected){
    state.cursorVisible = false;
    state.isPinching = false;
    updateCursorUI();
    if(state.dragging) cleanupDrag();
    debugBadge.textContent = "No hand (video live)";
    return;
  }

  const hand = results.multiHandLandmarks[0];
  const indexTip = hand[8];
  const rawX = (1 - indexTip.x) * innerWidth;
  const rawY = indexTip.y * innerHeight;

  if(state.smoothX === null){
    state.smoothX = rawX;
    state.smoothY = rawY;
  } else {
    state.smoothX += (rawX - state.smoothX) * SMOOTHING;
    state.smoothY += (rawY - state.smoothY) * SMOOTHING;
  }

  state.cursorX = state.smoothX;
  state.cursorY = state.smoothY;
  state.cursorVisible = true;

  const d = pinchDistance(hand);
  state.isPinching = d < PINCH_THRESHOLD;

  updateCursorUI();
  
  // ‚úÖ Update targeting based on game state
  if(state.gameEnded){
    updateRestartTargeted();
  } else {
    updateTargetedOption();
  }

  if(state.dragging) moveGhost();

  const pinchStart = state.isPinching && !state.wasPinching;
  const pinchEnd   = !state.isPinching && state.wasPinching;

  // ‚úÖ Handle pinch for restart or drag
  if(pinchStart){
    if(state.gameEnded && state.restartTargeted){
      handleRestart();
    } else if(!state.dragging && state.targetedOptionIndex !== null){
      startDrag(state.targetedOptionIndex);
    }
  }

  if(pinchEnd && state.dragging){
    handleDrop();
  }

  debugBadge.textContent =
    `PinchDist:${d.toFixed(3)} | Pinch:${state.isPinching?"YES":"NO"} | ${state.gameEnded ? `Restart:${state.restartTargeted?"YES":"NO"}` : `DropZone:${inRect(state.cursorX,state.cursorY,rect(dropZone))?"IN":"OUT"}`}`;

  state.wasPinching = state.isPinching;
}

/* ================= CAMERA ================= */
async function startCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoEl.srcObject = stream;
  await videoEl.play();

  const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  hands.onResults(onResults);

  const camera = new Camera(videoEl, {
    onFrame: async () => {
      await hands.send({ image: videoEl });
    }
  });

  camera.start();
}

updateHUD();
startCamera();
</script>

</body>
</html>